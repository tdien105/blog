---
layout: post
title:  "Accelerated Database Recovery"
date: 2023-07-27
categories: mssql
---
Have you ever thought that your SQL server takes too long to start up? Or when using SQL Availability Group and switching to another node for maintenance, did it also cause lengthy downtime? I've been there! So, in this post, I want to explore what's causing these problems.

When the SQL engine restarts after a crash, it tries to recover the database to its state at the time of the crash. This recovery process also happens during a failover.
Let's first understand the recovery process of the SQL server.

![sql recovery process](/assets/recovery_process.png "SQL recovery process")

Well, there are so many definitions here that need to be understood before going deeper. Let's break it down!

- **Logging**: Every transaction that hits the SQL server will be logged into the transaction log file before saving into the database file.
- **Committed transaction**: It's just as simple as it sounds. BEGIN TRANSACTION ... COMMIT TRANSACTION.
- **Uncommitted transaction**: Yeah, simple again. BEGIN TRANSACTION ... (and then the crash or failover happened).
- **Dirty data/page/checkpoint**: The SQL engine doesn't directly interact with data on disk. When it needs to read or modify data, it first brings the data into memory and then performs read and write operations there. The data that has been modified in memory is referred to as "dirty data" and in order to make it persistent, it must be written back to the disk. This operation of writing the data from memory back to disk is called a "checkpoint"
 
Now, here is a summary of the recovery process:
1. **Analysis**: This is the process where the SQL server will analyze the current status of the server/database to decide the appropriate next steps. What does it do?
    - First, from the last checkpoint, it will read forward to determine the state of each transaction:
        - Committed transactions not yet written to disk => redo (persist to disk).
        - Uncommitted transactions => undo (revert the changes).
2. **Redo**: Starting from the oldest uncommitted transaction, it reads forward to the end of the log and commits any transactions that were committed to the log but not the database file.
3. **Undo**: It starts from the end of the log, reads backward, and rolls back any transactions that were still open or weren't committed to the log.

hmm, So what is the limitation of this process ? Well, continue reading.
As you might imagine, the time needed to restore databases to their state when the system crashed relies heavily on the server's workload during that time. In simpler terms, the recovery duration is linked to the amount of work done by ongoing transactions and the time they were active. Consider a scenario where there are large transactions running. If a failover occurs (either you initiate it or someone else in your team does), it can lead to application downtime because the recovery process might take a significant amount of time (eg: 10 minutes! ) to complete.

Well, now we will see how the Accelerated Database Recovery (ADR) helps in this case.
What does ADR bring to the table ?
- Avoid having to scan the log from/to the beginning of the oldest active transaction => recovery time is not impacted by the long running transactions.
- The transaction log can be truncated aggressively.
- Reduce contention on the tempdb. Because the row verion will be stored on the user databases.

## How does ADR works?
![sql recovery process with ADR](/assets/recovery_process_adr.png "SQL recovery process with ADR")
